---
title:  "Operating System 개념 정리"
date: 2019-11-10 14:30:00
description: The history of Development Study
categories: [devKnowledge]
resource: true
comments: true
---
# Operating System 개념 정리
### `Process와 Thread`
##### 프로그램(Program)
  어떤 작업을 위해 실행할 수 있는 파일 <br>
##### 프로세스(Process)
- 컴퓨터에서 연속적으로 **실행되고 있는 컴퓨터 프로그램**
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
![Image]({{ site.baseurl }}/images/process.png)<br>


> 할당받는 시스템 자원의 예시 👉 CPU 시간, 운영되기 위한 메모리 주소 공간, Code, Data, Stack, Heap 구조의 독립된 메모리 영역

프로세스는 각각 독립된 메모리 영역(Code, Data, Heap, Stack의 구조)를 할당받는다. 기본적으로 **프로세스당 최소 1개의 메인 스레드를 가지고 있다** 각 프로세스는 별도의 주소공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스간의 통신(IPC, inter-process communication)을 사용해야한다.(파이프, 파일, 소켓을 이용한 통신 방법)<br>

##### 스레드(Thread)
- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스의 특정한 수행 경로
- **프로세스가 할당받은 자원을 이용하는 실행의 단위**
![Image]({{ site.baseurl }}/images/thread.png)<br>

스레드는 프로세스 내에서 각각의 Stack만 따로 할당받고, Code, Data, Heap 영역은 프로세스와 공유한다. 스레드는 한 프로세스에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간)같은 프로세스 내에 스레드끼리 공유하면서 실행되고 각 스레드는 별도의 레지스터와 스택을 가지고 있다. 같은 프로세스 안에 있는 여러 스레드는 같은 힙공간을 공유하는 반면, 프로세스는 다른 프로세스의 메모리에 직접 공유할 수 없다. 한 프로세스가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경결과를 즉시 볼 수 있다.(메모리를 공유하고 있기 때문)<br>

### `Multi Process와 Multi Thread`
##### 멀티 프로세스
- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.
- 장점 : 여러 개의 자식 프로세스 중 하나에 문제가 발생하면, 그 자식 프로세스만 종료되고 다른 프로세스에는 영향을 미치지 않는다.
- 단점
  - Context Switching에서의 오버헤드
    👉 Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 오버헤드가 발생한다.
    👉 프로세스는 각각의 독립된 메모리 영역을 할당받기 때문에, 프로세스 사이에 공유하는 메모리가 없어서 Context Switching이 발생하게 되면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
  - 프로세스 사이의 어렵고 복잡한 통신(IPC)
> MEMO
Context Switching : CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데, 이 작업을 Context Switching이라고 한다.
동작중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업이다.

##### 멀티 스레드
- 하나의 응용프로그램을 여러개의 스레드로 구성하고, 각 스레드에서 하나의 작업을 처리하도록 하는 것이다.
- 장점
  - 시스템 자원 소모 감소(자원의 효율성 증대) : 프로세스를 생성하여 자원을 할당받는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다(프로세스를 할당할 때, Code, Stack, Heap, Data라는 메모리를 할당 받아야 하는데, 스레드의 경우 Stack이외에는 프로세스의 자원을 공유하기 때문)
  - 시스템 처리량 증가(처리 비용 감소) : 스레드 간 데이터를 주고 받는 것이 간단해지고(공유자원), 시스템 자원 소모가 줄어들게 된다. 스레드 간 작업량이 작아 Context Switching이 빠르다.
  - 간단한 통신 방법으로 인한 프로그램 응답 시간을 단축(메모리 공유)

- 단점
  - 주의 깊은 설계가 필요하다.
  - 디버깅이 까다롭다.
  - 단일 프로세스 시스템의 경우, 효과를 기대하기 어렵다.
  - 다른 프로세스에서 스레드를 제어할 수 없다. (프로세스 밖에서 스레드 각각을 제어할 수 없다)
  - 멀티 스레드의 경우, 자원 공유의 문제가 발생한다. (동기화 문제)
  - 하나의 스레드에 문제가 발생하면, 전체 프로세스가 영향을 받는다.

##### 멀티 프로그램 대신 멀티 스레드를 사용하는 이유?
- 프로그램을 여러개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것
![Image]({{ site.baseurl }}/images/multi_thread.png)<br>
1. 자원의 효율성 증대
  - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행하면, 프로세스를 생성하여 **자원을 할당받는 시스템 콜이 줄어** 자원을 효율적으로 관리할 수 있다.
  - 프로세스 간의 Context Switching시, 단순히 CPU 레지스터 교체뿐만 아니라 RAM과 CPU사이의 캐쉬 메모리에 대한 데이터도 초기화 되기 때문에 오버헤드가 크다.
  - 스레드간의 통신이 용이하여 시스템 자원 소모가 줄어든다.
2. 처리 비용 감소 및 응답 시간 단축
  - 프로세스 간의 통신(IPC)보다 스레드간의 통신이 비용이 적게든다.
  - 프로세스간의 전환 속도보다 스레드 전환 속도가 더 빠르다.(Context Switching)

**주의할 점 : 동기화 문제 / 스레드 간 자원공유는 전역변수를 이용하므로 스레드간 충돌을 주의해야 한다**

### `Pipeline`
- Fetch, Decode, Execute 순으로 파이프라인이 진행된다.
- Fetch : 메모리로부터 Instruction을 가져온다.
- Decode : Instruction을 담은 Register를 해석한다.
- Execute : 각종 read, shift, ALU, write 등을 수행한다.
파이프 라인 : 각 CPU의 다른 부분을 사용하는 Fetch/Decode/Execute를 동시에 사용하기 위한 방법
- Control Harzard : 프로그램 의존성에 의해 발생하게 되는데, 해당 명령어가 끝날 때가지 다음 명령어가 수행되지 못하는 것(원래 순차적으로 명령어의 단계가 끝나면 다음 명령어를 수행해야 하는데, 아예 한 단계가 끝날 때까지 수해오디지 못하는것 - 파이프라인적이지 못한것)
- Data Harzard : 이전 명령어의 결과를 기반으로 다음 명령어가 수행되는 에러

### `가비지 콜렉션`
- 동적 할당된 메모리 영역 가운데 더 이상 사용할 수 없게된 영역을 탐지하여 자동으로 해제하는 기법
- 장점 : 비 유효 메모리 접근 차단, 이중 해제 차단, 메모리 누수 차단
- 단점 : 메모리 해제 결정에 따른 비용
- 방법 : 포인터 추적 방식
  👉 한 개 이상의 변수가 접근 가능한 메모리는 사용할 수있는 메모리로 간주, 아닌 경우는 해제
  👉 Mark and Sweep : 각 메모리 할당 영역에 1비트 메모리를 남기고, mark단계에서 변수가 가르키는 메모리는 true라고 표시, sweep 단계에서 false인 부분은 모두 해제

### `Call back 함수`
##### Callback
  - 어떤 이벤트가 발생했을 때, 나에게 알려달라고 핸들러를 등록하는 작업
  - call을 하는 주체는 사용자가 아니라 OS이다.(주체권의 차이가 있음)
  - ex) < java script > : >
    a=[3,1,2]; function b(v1, v2){console.log(‘c’, v1, v2); return 0}; a.sort(b); console.log(a);
    b함수의 경우, 유저가 호출하는 것이 아니라 sort에 주입하여 필요에 따라 sort가 호출하는 함수임 - callback함수
  - 일반적인 프로그래밍 방식에서는 개발자가 필요한 시점에 어떤 특정 기능을 호출하는 방식으로 프로그래밍이 진행되지만, 시스템 입장에서 필요한 타이밍에 맞춰 함수를 호출할 상황(특정 이벤트에서)이 종종 있다.
  - **다른 함수의 매개변수로 호출될 함수를 사용하고, 특정 이벤트가 발생하고 나서 그 매개변수가 다시 호춠되어 수행되는 것**

##### Callback Function
  - passed as an argument to another function, and **(다른 함수의 인자로 이용되는 함수)**
  - is invoked after some kind of event **(어떤 이벤트에 의해 호출되어지는 함수)**\
{% highlight c++ %}
pm = function(a,b,callback) {
  callback(a+b,a-b);
}
pm(5,10,function(res1,res2){
  console.log(res1);
  console.log(res2);
})
{% endhighlight %}
이러한 코드가 있다고 하면, pm에 일단 함수를 지정해준다.
pm은 밑에 function(res1,res2)이란 함수를 인자로 사용하였다.
여기서 function(res1,res2)는 이벤트라고 생각하면 된다.

- 콜백을 넘겨받는 함수는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 나중에 실행할 수도 있다(비동기적)

{% highlight c++ %}
function getData(callbackFunc) {
	$.get('https://domain.com/products/1', function(response) {
		callbackFunc(response); // 서버에서 받은 데이터 response를 callbackFunc() 함수에 넘겨줌
	});
}

getData(function(tableData) {
	console.log(tableData); // $.get()의 response 값이 tableData에 전달됨
});
{% endhighlight %}
이러한 경우, getData 함수는 function(tableData)라는 함수를 매개변수로 던지고, get()함수를 실행하고 callbackFunc(response)를 통해 tableData에 response를 전달해준다.

### `Deadlock - 교착상태`
- 개념 : 동일한 자원을 공유하고 있는 두 개 이상의 컴퓨터 프로그램들이 상대방이 자원에 접근하는 것을 방해함으로써, 두 프로그램 모두 기능이 중지되는 상황을 말한다.
![Image]({{ site.baseurl }}/images/deadlock.png)<br>
- 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황! 👉 어떤 프로세스가 자원을 요청했을 때, 그 시각에 자원을 사용할 수 없으면 대기상태로 들어간다.
- 결국 위 사진 처럼 process1과 2가 대기 상태로 들어가면 교착 상태가 된다.

데드락 : 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황
어떤 프로세스가 자원을 요청하였을 때, 해당 자원을 사용할 수 없는 상황이 생기고 대기 상태에 들어가게 되는데 이때 대기 상태에 들어가게 된 프로세스들이 실행상태로 변경될 수 없을 때 데드락이 발생할 수 있다.
1. 상호 배제(Mutual Exclusion) : 자원은 한번에 한 프로세스만이 사용할 수 있다.
2. 점유 대기(Hold and Wait) : 하나의 자원을 점유하고 있으면서, 다른 프로세스에 할당되어 있는 자원을 점유하기 위해 대기하는 프로세스가 있다.
3. 비선점 (No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다. [Monitor공부할 때 뺏는 경우가 있었음. 작업의 우선순위가 정해져있었기 때문에 대기 큐로 들어갔음.]
4. 순환대기(Circular Wait) : 프로세스의 집합에서 P0는 P1이, P1은 p2가 점유한 자원을, PN은 P0가 점유한 자원을 요구한다.

##### 이 네 가지 경우를 피한다면, 교착 상태 즉 데드락을 피할 수 있다.

1. 상호 배제 👉 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
2. 점유 대기 👉 프로세스가 실행되기 전 필요한 모든 자원을 모두 할당한다. (대기할 필요가 없어짐)
3. 비선점 👉 자원을 점유하고 있는 가 다른 자원을 요구할 때, 점유하고 있는 자원은 반납하고 대기한다.
4. 순환대기 👉 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.


### `참고자료`
신입 개발자 면접용 컴퓨터공학 기본지식 : [Patrasche](http://softwarepatrasche.blogspot.com/2016/04/blog-post.html)<br>
프로세스와 스레드의 차이 : [gmlwjd9405](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)<br>
Callback에 대해서 : [guxlabview](https://guslabview.tistory.com/214)
자바스크립트 비동기 처리와 콜백함수 : [joshua1988](https://joshua1988.github.io/web-development/javascript/javascript-asynchronous-operation/)
