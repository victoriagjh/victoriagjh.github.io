---
title:  "Database 개념 간단정리"
date: 2019-11-09 14:30:00
description: The history of Development Study
categories: [devKnowledge]
resource: true
comments: true
---
# Database 개념 간단정리
### `NoSQL과 RDBMS의 차이`
- RDBMS
  명확한 스키마와 스키마들간의 관계가 존재한다. 해당 스키마에 맞지 않는 데이터는 삽입될 수 없고, 데이터의 중복을 지양한다.<br>
  데이터의 무결성을 강조하며, ACID(원자성-Atomicity, 일관성-Consistency,격리성-Isolation,지속성-Durability)의 특성을 기반으로 트랜잭션을 수행한다.<br>
- NoSQL
  관계형 데이터베이스보다 유연한 구조로 스키마나 관계가 존재하지 않는다. 단순 데이터를 사용하기 위해 사용되었고, 데이터베이스이 수평적인 확장이 가능하여 분산 서버를 여러대 두고 클러스터링을 통해 하나의 데이터베이스를 구축하는 방향으로 진행된다.<br>
  스키마에 대해 정의가 되어있지 않아, 애트리뷰트의 수정 및 삭제가 유연하다.<br>

### `ERD(Entity Relationship Diagram)`
- 개요 : 엔티티간의 관계와 스키마(각 스키마의 애트리뷰트)들을 명확하게 나타내기 위한 다이어그램이다. 시스템을 분석하고 설계하는데 매우 유용하다. <br>
  자세한 내용을 보고 싶다면! [정리 내용](http://hkpark.netholdings.co.kr/web/manual/default/manual_print.asp?menu_id=102668&id=1142)<br>

### `데이터베이스 정규화`
- 정규화 : **데이터의 중복을 최소화하도록 데이터를 구조화하는 프로세스**. 이상현상 **(삽입이상, 삭제이상, 수정이상)** 을 제거하기 위한 목적이디.
정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF 까지 있다. 비공식적인 표현으로는 3NF가 되었으면 정규화되었다고 말한다. 3NF 테이블 대부분이 삽입, 변경, 삭제 이상이 없으며, 3NF 테이블의 대부분이 BCNF, 4NF,5NF이다. <br>
1. 제 1 정규형
##### 릴레이션에 속한 모든 속성의 도메인이 원자값으로 구성되어 있으면 제 1 정규형에 속한다.
![Image]({{ site.baseurl }}/images/1NFx.png)<br>
위 사진은 Course_ID가 원자값으로 구성되어 있지 않기 때문에, 아래 사진과 같이 표현해야 한다.
![Image]({{ site.baseurl }}/images/1NFo.png)<br>

2. 제 2 정규형
##### 제 1 정규형을 만족하면서, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2 정규형이다.
![Image]({{ site.baseurl }}/images/2NFx.png)<br>
위와 같은 릴레이션을 학번, 학부, 등록금 테이블과 학번, 과목코드, 성적 테이블로 분리할 수 있을 것이다. **부분 함수 종속성을 제거해야한다**
정규화 과정에서 주의할 점은 정규화를 통해 분해된 릴레이션들이 조인을 통해 원래의 구조로 복원될 수 있어야 한다는 것이다.<br>

3. 제 3 정규형
##### 제 2 정규형을 만족하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다.
이행적 함수 종속이라는 것에 예시를 들어보자면,<br>
> 학번-> 학부
  학부-> 등록금
  학번->등록금

이러한 구조에서, 학번이 등록금을 결정하게 되는데 사실은 학부가 등록금을 결정하는 것이지 학번에 따라 결정되는 것은 아니다. 그냥 이런 요소를 쪼개주면 된다.<br>
![Image]({{ site.baseurl }}/images/3NFo.png)<br>

### `대용량 트랜잭션 처리`
트랜잭션 : 질의를 하나의 묶음으로 처리하여 중간에 실행이 중단되었을 경우, **처음부터 다시 실행하는 Rollback을 수행하고, 오류없이 실행을 마치면 commit을 하는 실행단위** 이다.<br>
즉, 한번 질의가 수행되면 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위이다.<br>
(DBMS의 성능은 초당 트랜잭션의 실행수-TPS:Transaction per second로 측정한다)<br>

##### 트랜잭션 사용 이유
- DB 서버에 여러 클라이언트가 동시에 액세스하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 데이터 부정합을 방지하고자 사용한다.<br>
  프로세스를 병렬로 처리하지 않고, 하나의 프로세스만 처리하면 효율이 너무 떨어지게 된다. <br>
  👉 For. 병렬로 처리할 수 밖에 없는 상황으로 부정합을 방지하고자 하는 상황 <br>

##### 대용량 트랜잭션
  트랜잭션을 수행할 때는, 반드시 로그를 기록하게 되어있다. Full 복구 모드의 대용량 트랜잭션에는 이렇게 행별 트랜잭션 로그를 기록하는 방식이 용량 문제와 병목 현상으로 인한 속도 문제를 야기한다.
  👉 최소 로깅 작업 : 행 별 변경사항을 로깅하는 것이 아니라 table별로 로깅 작업을 진행하며, 테이블 삭제시 delete가 아니라 truncate를 수행한다.
  (Delete - 각각의 데이터에 트랜잭션 로그의 삭제사항을 전부 기록 👈👉 Truncate는 테이블이 지웠다는 이벤트만 기록하고 종료)
  👉 Full 복구 모델에서는 사용 불가하다. Simple 및 Bulk Logged 모델에서만 사용 가능
  👉 무결성 제약조건을 따르지 않는다

##### `쿼리 튜닝`
- IO를 줄이기 위한 노력. 꼭 필요한 데이터만을 스캔할 수 있도록 스캔 범위를 조정하는 작업을 포함한다.
- 최적화 : 인덱스를 활용할 것인가. 병목 구간을 정확히 파악했는가?

##### `Index`
- 관계형 데이터베이스에서 search를 빠르게 하기위한 자료구조이다.
- 인덱스를 사용하게 되면, 인덱스와 관련된 주소값을 저장하는 공간이 생기고, 단일 필드 인덱스를 사용하는 것인지 다중 필드 인덱스를 사용하는 것인지 역시 중요하다.
- Balanced Tree 구조로 저장되며, 소팅이 되어 들어간다.
- 키값을 기반으로 테이블에서 검색과 정렬 속도를 향상시킨다. 가장 고유한 값을 갖는 필드를 먼저 드라이빙하여 인덱싱하는 것이 성능에 좋다.

### `조인 종류`
![Image]({{ site.baseurl }}/images/join.png)<br>
- SELF JOIN : 동일한 테이블을 연결해서 조회하는 방법
- INNER JOIN : 교집합
- OUTER JOIN : 합집합 또는 (합집합 - 교집합)

### `데이터 무결성 유형`
데이터의 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다. 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지한다.
##### 1. 개체 무결성(Entity Integrity)
  모든 테이블이 기본 키(primary key)로 선택된 필드(column)를 가져야 한다. 기본키로 선택된 필드는 고유값을 가져야 하며, 빈 값은 허용하지 않는다.
  (개체의 프라이머리 키로 고유성을 둔다)
##### 2. 참조 무결성
  참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되는 것을 말한다. (두 테이블의 내용이 같아야 한다는 것)
##### 3. 범위 무결성(Domain)
  테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, NULL값의 허용 등에 대한 사항을 정의하고, 올바른 데이터의 입력이 되었는 지 확인하는 것이다. (해당 필드에 정해놓은 필드타입과 같은 타입의 값이 들어가야 한다는 점)

### `트랜잭션의 특성`
- 원자성(Atomicity)
  트랜잭션의 작업이 **부분적으로 실행되거나 중단되지 않는 것을 보장** 하는 것을 말한다.
  All or Nothing의 개념으로 일부분만 실행하지 않는다!는 것을 의미한다. (Rollback하여 수행, 성공하면 Commit)

- 일관성(Consistency)
  트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지해야 한다.
  트랜잭션 이후, **Domain이 바뀌지 않아야 한다** (int값이 string으로 바뀌면 안된다)

- 격리성(Isolation)
  트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하게 하는 것을 보장한다.
  트랜잭션끼리 서로 간섭하면 안된다(Lock을 이용)

- 지속성(Durability)
  성공적으로 수행된 트랜잭션은 영원히 반영이 된다.
  Commit을 하면 상태가 지속해서 보장된다.

### `참고자료`
신입 개발자 면접용 컴퓨터공학 기본지식 : [Patrasche](http://softwarepatrasche.blogspot.com/2016/04/blog-post.html)<br>
[관계형 데이터베이스] - 무결성(Integrity) : [Untitled](https://untitledtblog.tistory.com/123)<br>
트랜잭션과 ACID 특성을 보장하는 방법 : [victorydntmd](https://victorydntmd.tistory.com/129)<br>
