---
title:  "도커 기본"
date: 2020-11-25 19:22:00
description: Inflearn
categories: [docker]
resource: true
comments: true
---

# Docker를 쓰는 이유
- 어떤 프로그램을 다운받는 과정을 간략하게 하기 위함
  - docker run -it redis


# Docker란 무엇인가
- 컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구
- 컨테이너 기반의 오픈소스 가상화 플랫폼이며 생태계
- **컨테이너 In Server**
  - 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줌
  - AWS, Azure, Google Cloud 등 어디서든 실행가능하게 해줌

## 컨테이너
- **코드와 모든 종속성을 패키지화**하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위

## 컨테이너 이미지
- 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행가능한 소프트웨어 패키지
- 런타임에 컨테이너가 되고, **도커 컨테이너의 경우 도커 엔진에서 실행될 때 이미지가 컨테이너가 됨**
- 리눅스와 윈도우 기반 어플리케이션 모두에서 사용할 수 있는 컨테이너화된 소프트웨어는 인프라에 관계없이 항상 동일하게 실행됨
- 컨테이너는 소프트웨어를 환경으로부터 격리시키고, 개발과 스테이징의 차이에도 불구하고 균일하게 작동하도록 보장함
  
![Image]({{ site.baseurl }}/images/docker_1.png)<br>
- 도커 이미지를 기반으로 도커 컨테이너(이미지의 인스턴스)를 만듬
- 도커 컨테이너를 실행하여 어플리케이션이 안에서 돌아감

## 도커 사용 Flow
- 도커 클라이언트에서 `$ docker run hello-world` 입력
- 도커 서버 👉 [이미지 Cache 보관장소]에서 hellow-world라는 이미지를 찾음
- 없을 시 도커 허브(이미지들을 보관)로 이동하여 pull 하여 가져옴

# 도커와 기존의 가상화 기술과의 차이를 통한 컨테이너 이해
## 가상화 기술 나오기 전
- 한대의 서버를 하나의 용도로만 사용
- 남는 서버 공간 방치
- 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영
- 안정적이나 비효율적임

## 하이퍼바이저 기반의 가상화 출현
### 하이퍼바이저
- 호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어, 그리고 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간 관리자
- *네이티브 하이퍼바이저* 와 **호스트형 하이퍼바이저-윈도우/리눅스..**로 구분됨
  - *네이티브 하이퍼바이저*
    - 하드웨어를 직접 제어
    - 별도의 호스트 OS가 없어 오버헤드가 적음
    - 여러 하드웨어 드라이버를 설치해야 하므로 설치가 어려움
    - ![Image]({{ site.baseurl }}/images/docker_native_hyper.png)<br>

  - *호스트형 하이퍼바이저*
    - 일반적인 소프트웨어 OS 위에서 실행됨 [호스트 OS 위에서]
    - 하드웨어 자원을 VM 내부의 게스트 OS의 에뮬레이트 하는 방식 
    - 게스트 OS 종류에 대한 제약이 없음
- 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용가능
- ![Image]({{ site.baseurl }}/images/docker_hyper.png)<br>

## 컨테이너 가상화 기술
### Docker V.S. 기존 가상화기술(VM)
- ![Image]({{ site.baseurl }}/images/docker_vm.png)<br>
#### Docker
- 하이퍼바이저와 게스트 OS가 필요하지 않아 더 가벼움
- 어플리케이션을 실행할 때, 호스트 OS 위에 어플리케이션의 실행 패키지인 이미지만 배포하면 됨
- 컨테이너가 제공하는 격리 기능 내부에 샌드박스가 있지만, 여전히 같은 호스트의 다른 컨테이너와 동일한 커널을 공유함
- 컨테이너 내부에서 실행되는 프로세스는 호스트 시스템에서 볼 수 있음

#### VM
- 어플리케이션을 실행할 때, VM을 띄우고 자원을 할당하고 게스트 OS를 부팅하여 어플리케이션을 실행해야함
- 가상머신과 함께 VM 내부에서 실행되는 모든 것은 호스트 운영체제 또는 하이퍼바이저와 독립되어 있음
- 가상 머신 플랫폼은 특정 VM에 대해 가상화 프로세스를 관리하기 위해 프로세스를 시작, 호스트 시스템은 그것의 하드웨어 자원을 VM에 할당함
- 오버헤드가 큼

#### 공통점
  - 기본 하드웨어에서 격리된 환경 내에 어플리케이션을 배치하는 방법
- 차이점
  - 격리된 환경을 얼마나 격리시키는 가의 차이

## Docker 프로세스 도면
- ![Image]({{ site.baseurl }}/images/docker_2.png)<br>
- 커널은 공유됨
- 컨테이너끼리 격리는 되어있지만, 하드웨어는 공유함

## 도커 컨테이너를 격리시키는 방법
### C Group
- CPU, 메모리, Network Bandwidth, HD i/o 등 프로세스 그룹의 시스템 리소스 사용량을 관리
- 어떤 어플이 사용량이 너무 많은 경우, C group에 집어 넣어서 CPU와 메모리 사용 제한가능
### 네임스페이스
- 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
- 별개의 독립된 공간을 사용하는 것 처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술